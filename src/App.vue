<template>
	<div id="app">
		<video id="video" playsinline></video>
		<canvas id="output" />
		<div class="emoji" :style="{ left: emojiX, top: emojiY }">{{ emoji }}</div>
	</div>
</template>

<script>
import * as bodyPix from '@tensorflow-models/body-pix';

const emojis = ['ðŸ˜€', 'ðŸ¤ª', 'ðŸ™ˆ', 'ðŸ¤¬', 'ðŸ¤¯', 'ðŸ¥¶', 'ðŸ’©'];

const state = {
	video: null,
	stream: null,
	net: null,
	videoConstraints: {},
	frame: 0,
};

function isAndroid() {
	return /Android/i.test(navigator.userAgent);
}

function isiOS() {
	return /iPhone|iPad|iPod/i.test(navigator.userAgent);
}

function isMobile() {
	return isAndroid() || isiOS();
}

async function getVideoInputs() {
	if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
		console.log('enumerateDevices() not supported.');
		return [];
	}

	const devices = await navigator.mediaDevices.enumerateDevices();

	const videoDevices = devices.filter((device) => device.kind === 'videoinput');

	return videoDevices;
}

function stopExistingVideoCapture() {
	if (state.video && state.video.srcObject) {
		state.video.srcObject.getTracks().forEach((track) => {
			track.stop();
		});
		state.video.srcObject = null;
	}
}

async function getDeviceIdForLabel(cameraLabel) {
	const videoInputs = await getVideoInputs();

	for (let i = 0; i < videoInputs.length; i++) {
		const videoInput = videoInputs[i];
		if (videoInput.label === cameraLabel) {
			return videoInput.deviceId;
		}
	}

	return null;
}

// on mobile, facing mode is the preferred way to select a camera.
// Here we use the camera label to determine if its the environment or
// user facing camera
function getFacingMode(cameraLabel) {
	if (!cameraLabel) {
		return 'user';
	}
	if (cameraLabel.toLowerCase().includes('back')) {
		return 'environment';
	} else {
		return 'user';
	}
}

async function getConstraints(cameraLabel) {
	let deviceId;
	let facingMode;

	if (cameraLabel) {
		deviceId = await getDeviceIdForLabel(cameraLabel);
		// on mobile, use the facing mode based on the camera.
		facingMode = isMobile() ? getFacingMode(cameraLabel) : null;
	}
	return { deviceId, facingMode };
}

/**
 * Loads a the camera to be used in the demo
 *
 */
async function setupCamera(cameraLabel) {
	if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
		throw new Error('Browser API navigator.mediaDevices.getUserMedia not available');
	}

	const videoElement = document.getElementById('video');

	stopExistingVideoCapture();

	const videoConstraints = await getConstraints(cameraLabel);

	const stream = await navigator.mediaDevices.getUserMedia({ audio: false, video: videoConstraints });
	videoElement.srcObject = stream;

	return new Promise((resolve) => {
		videoElement.onloadedmetadata = () => {
			videoElement.width = videoElement.videoWidth;
			videoElement.height = videoElement.videoHeight;
			resolve(videoElement);
		};
	});
}

async function loadVideo(cameraLabel) {
	try {
		state.video = await setupCamera(cameraLabel);
	} catch (e) {
		let info = document.getElementById('info');
		info.textContent = 'this browser does not support video capture,' + 'or this device does not have a camera';
		info.style.display = 'block';
		throw e;
	}

	state.video.play();
}

function segmentPerson() {
	async function bodySegmentationFrame() {
		const personPart = await state.net.segmentPersonParts(state.video, {
			flipHorizontal: false,
			internalResolution: 'medium',
			segmentationThreshold: 0.7,
		});
		if (personPart.allPoses[0].score > 0.4) {
			let part = personPart.allPoses[0].keypoints[0];
			this.$set(this, 'emojiX', Math.round(part.position.x) + 'px');
			this.$set(this, 'emojiY', Math.round(part.position.y) + 'px');
		}

		requestAnimationFrame(bodySegmentationFrame.bind(this));
	}

	bodySegmentationFrame.call(this);
}

async function bindPage() {
	state.net = await bodyPix.load();
	await loadVideo();
	segmentPerson.call(this);
}

navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;

export default {
	name: 'app',
	data: () => ({
		emojiX: 0,
		emojiY: 0,
		emoji: emojis[Math.round(Math.random() * emojis.length - 1)],
	}),
	mounted: function() {
		bindPage.call(this);
	},
};
</script>

<style>
body {
	margin: 0;
	width: 100%;
}
.emoji {
	position: absolute;
	color: white;
	font-size: 50px;
	transform: translate(-50%, -50%);
}
</style>
